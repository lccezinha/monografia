%twoside frente e verso do contrário oneside
\documentclass[msc, oneside]{ppgiathesis}
\usepackage{listings}
\usepackage{color}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{epsfig}
\usepackage{epstopdf}
\usepackage{bigstrut}
\usepackage{float}
%Referências no Formato ABNT:
\usepackage[alf]{abntcite}
\usepackage[latin1]{inputenc}
\usepackage[Algoritmo]{algorithm}
\usepackage{algorithmic}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Hifenizacao

\hyphenation{co-nhe-ci-men-to tra-ba-lhan-do com-pos-to
a-pli-ca-do}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Nome do Aluno
\author{Luiz Cezer Marrone Filho}

% Titulo da dissertação
\title{Desenvolvimento de Software utilizando abordagem do Behavior Driven Development}

% Orientador
\adviser{Maurício Henning}

% Cidade
\address{Joinville}

% Data
\date{2015}

% Área de Concentração
\majorfield{Pós Graduação em Engenharia de Software}

\begin{document}

% Folha de Rosto
\frontpage

% Informações
\informations{Filho}{Luiz Cezer Marrone}
{Desenvolvimento de Software}{Teste de Software}{BDD}

% Dedicatória
% \begin{dedicatory}
%     Inserir a dedicatória (Alinhada a direita)
% \end{dedicatory}


% % Agradecimentos
% \acknowledgements

% Inserir os agradecimentos. Os agradecimentos devem ocupar no
% máximo uma página, devem ser justificados na largura da página e
% com um afastamento de parágrafo na primeira linha de 1,27 cm. O
% espaçamento entre linhas deve ser de 1,5 linhas. Não deve haver
% espaçamento adicional entre parágrafos.

% Sumário (não alterar)
\tableofcontents

% Lista de Figuras (Retirar se não existir)
\listoffigures

% Lista de Tabelas (Retirar se não existir)
\listoftables

% Lista de Símbolos (Retirar se não existir)
% \listofsymbols

% Lista de Abreviações (Retirar se não existir)
% \listofabreviations


% Resumo
\resumo

% \noindent para não criar parágrafo (Retirar se existir parágrafo)
\noindent Utilizar testes de \textit{software} no seu desenvolvimento
irá proporcionar um código de melhor qualidade, confiança e segurança. O uso de TDD irá
ajudar ao desenvolvedor a ter um código melhor e mais simples e o BDD irá ajudar
na validação de uma especificação de funcionalidade.
Esse trabalho tem como objetivo mostrar através de um referencial teórico
e um estudo prático, como a utilização de técnicas de TDD e BDD podem ajudar
a equipes ágeis a chegar nesse objetivo.
\begin{keywords}
  Desenvolvimento de Software, Teste de Software, BDD, TDD
\end{keywords}

% Abstract
\abstract

% \noindent para não criar parágrafo (Retirar se existir parágrafo)
\noindent Missing...
\begin{keywords}
    Software Development, Software Test, BDD, TDD
\end{keywords}

% Não remover
\mainmatter

% Muda a posição e o algorísmo das páginas e reinicia o contador
\changepage

\chapter{Introdução}\label{cap_1}

Desenvolver \textit{software} é uma tarefa complicada, devido aos vários fatores
que estão envolvidos na sua construção e devem ser avaliados antes mesmo do projeto ser iniciado.
Porém nos dias atuais, entregar um \textit{software} funcionando não basta, é preciso
que o produto entregue tenha qualidade, segurança e atenda a real necessidade para o qual ele
se propõe.

Entre as técnicas que tentam melhorar a acertividade e a qualidade do \textit{software} entregue,
surge o TDD. O TDD (\textit{Test Driven Development} ou Desenvolvimento Guiado por Testes) visa minimizar
os problemas do desenvolvimento e perca de tempo com \textit{debug}, adotando a técnica de criar testes
antes de criar código. \cite{TDD:Aniche}

Com essa troca de hábito o desenvolvedor irá primeiro criar um código que irá falhar,
após isso irá criar um código o mais simples possível apenas para que o teste antes falho, funcione.
Na última etapa o desenvolver irá codificar a melhor solução para resolver aquele teste,
sempre focando na simplicidade. Ao final desse processo, já é possível ter um código simples, que solucione o problema
testado e feito da melhor maneira possível. \cite{TDD:Aniche}

O TDD foca no código e nas suas melhores práticas, porém para validar se a funcionalidade entregue
realmente cumpre seu papel é preciso uma outra abordagem. O BDD surge então como um complemento ao TDD,
onde ao invés de focar no código, irá focar no comportamento e tentará validar se o código entregue
consegue garantir que o comportamento esperado pelo \textit{software} esteja correto. \cite{BDD:DanNorth}

Além disso o BDD permite uma forma de integrar equipes de negócio e desenvolvimento, fazendo com que as duas
falem a mesma linguagem e tenham um objetivo único, entregar \textit{software} com qualidade e que atenda
os requisitos esperados pelo cliente. \cite{BDD:Sanchez} \cite{BDD:CasaDoCodigo}

Esse trabalho tem como foco conceitualizar sobre o uso das técnicas de TDD e BDD
no desenvolvimento ágil de \textit{software} e através de um estudo experimental avaliar os
benefícios da utilização dessas abordagens.

\section{Objetivo Geral}

Apresentar por meio de um estudo experimental as vantagens do desenvolvimento de \textit{software} utilizando
a abordagem do BDD.

\section{Objetivos Específicos}

\begin{enumerate}
  \item Contextualizar por meio de referencial teórico sobre métodos ágeis, testes e qualidade do \textit{software};
  \item Contextualizar por meio de referencial teórico as práticas e como desenvolver \textit{software} utilizando abordagem do TDD e do BDD;
  \item Desenvolver um exemplo prático utilizando BDD para demonstrar como essa abordagem auxília no
  desenvolvimento de \textit{software};
\end{enumerate}

\section{Justificativa do Trabalho}

Os riscos de se desenvolver \textit{software} sem o mínimo de testes é muito grande.
Esses riscos vão desde atrasos no projeto, demora na resolução de \textit{bugs}, rigidez
na hora de executar uma alteração no projeto. Além desses problemas estruturais como código
mal feito também podem surgir problemas na hora de validar se o código entregue realmente
atende a necessidade para o qual ele se proprõe.

A utilização da técnica de TDD pelos desenvolvedores irá causar uma mudança na forma como
o desenvolver irá escrever seu código. Abordando essa técnica, o desenvolver irá escrever sempre
ao menos um teste antes de criar determinado código, fazendo essa troca na ordem no seu dia a dia
o desenvolvedor irá se forçar a sempre focar em uma solução simples que irá resolver o problema
da melhor maneira e obtendo um \textit{feedback} constante de seu trabalho.
Dessa forma o código ficará mais enxuto, simples e com um mínimo de cobertura de testes.
\cite{TDD:Aniche}

Porém para equipes ágeis que utilizam \textit{Scrum} apenas código entregue com qualidade não basta,
é preciso um modo para validar se o código que foi escrito, realmente irá atender a necessidade de
negócio para o qual ele foi proposto. Com a utilização do BDD é possível integrar equipes de áreas
diferentes para escrever especificações de \textit{software} executáveis, através das \textit{User Stories}
do \textit{Scrum} e assim conseguir validar a funcionalidade entregue. \cite{BDD:CasaDoCodigo}

Dessa forma, o uso de TDD e BDD no processo de desenvolvimento de \textit{software}, pode ser
demonstrado de forma simples em aplicações \textit{Ruby}, que além de agilizar o desenvolvimento
também oferece vários \textit{frameworks} para aplicação do TDD e BDD.

\section{Estrutura do Trabalho}

O trabalho se divide em seis capítulos, sendo o primeiro capítulo responsável pela contextualização
do tema, definindo os objetivos e a justificativa pela escolha do trabalho.

O segundo capítulo trata de todo o embasamento teórico, onde serão tratadas todos os conceitos
para o claro entendimento do trabalho. O terceiro capítulo apresenta o estudo experimental,
onde será construída uma aplicação utilizando as técnicas de teste que foram conceituadas no capítulo anterior e
ao final do desenvolvimento apontar as principais vantagens e conclusões sobre o estudo desenvolvido.
O quarto capítulo apresenta as discussões sobre os resultados obtidos.

O quinto capítulo apresentará as considerações finais do trabalho. E no sexto e último capítulo
serão apresentadas as referências bibliográficas sobre os assuntos abordados no trabalho.

\chapter{Referencial Teórico}\label{cap_2}

Neste capítulo serão apresentados os principais conceitos que serão abordados durante o trabalho.

\section{Falhas em projetos de software}

Desenvolvimento de \textit{software} é uma tarefa complicada para se praticar.  Muitas questões devem ser levadas
em conta antes mesmo de iniciar a codificação, por exemplo, é preciso estudar sobre o problema que deve ser
solucionado, escolher a melhor tecnologia para o projeto, estudar a viabilidade e planejar uma metodologia
que consiga organizar e gerenciar o projeto da melhor forma.

Além desses fatores, existem outros que devem ser seguidos, como boas práticas de desenvolvimento de \textit{software}, padrões de desenvolvimento pela equipe para que todos possam trabalhar da melhor forma em conjunto.
Entre os pontos importantes dentro do processo, existe o teste de \textit{software}, que deve ser feito
para garantir que o que foi codificado está funcionando e também irá suprir a necessidade do cliente. \cite{Pressman} \cite{Beck}

Testar \textit{software} de maneira manual, abrindo todas as telas do projeto e clicando componente por componente é uma tarefa complicada, demorada e fica inviável a medida que projeto cresce. Além do fato que uma
nova linha de código adicionada no projeto pode fazer com que todo o \textit{software} pare de funcionar. \cite{TDD:Aniche}

Para tentar sanar esses problemas e viabilizar que o \textit{software} ainda seja testado é preciso mudar a
abordagem para uma abordagem que facilite a forma como o desenvolvedor irá testar seu código, duas dessas
abordagens comumente usadas por equipes ágeis são: TDD e BDD.

\section{Metodologias Ágeis}

Visando minimizar problemas do desenvolvimento de \textit{software} sem algum planejamento é preciso adotar uma metodologia que ajude no processo de planejamento e na solução a ser desenvolvida.

Segundo \cite{Fowler} citado por \cite{Passuelo} "Metologias impõem um processo disciplinado no desenvolvimento
de \textit{software}, com objetivo  de torná-lo mais previsível e mais eficiente".

Porém o problema de muitas metologias é a burocrácia. Esas metodologias são focadas em documentação e gerenciamento rígido do projeto, muitas vezes acabam sendo vistas como um grande atraso para o projeto, já que a grande maioria
do tempo do projeto será gasto levantado requisitos e documentando todas as ações do sistema, antes mesmo de ele ser
codificado. \cite{Fowler}

Então nos anos noventa, surge uma reação a essas metodologias mais rígidas, são as chamadas metodologias ágeis
no processo de desenvolvimento de \textit{software}.

Criado por Kent Beck, com uma equipe de desenvolvedores experientes, o Manifesto Ágil é
o documento que reune todas as práticas e princípios dos métodos ágeis
dentro do processo de desenvolvimento \cite{Beck}. O manifesto Ágil possui valores, que são eles:

\begin{itemize}
  \item \textbf{Indivíduos e interações} mais que processos e ferramentas;
  \item \textbf{\textit{Software} em funcionamento} mais que documentação detalhada;
  \item \textbf{Colaboração com cliente} mais que negócios e contratos;
  \item \textbf{Responder a mudança} mais que seguir um plano;

  Ou seja, mesmo havendo valor nos itens a direita, valorizamos mais os itens a esquerda. \cite{ManifestoAgil}
\end{itemize}

Além dos valores, o Manifesto Ágil se baseia em alguns princípios:

\begin{itemize}
  \item Satisfazer o cliente por meio de entregas adiantadas e contínuas do \textit{software};
  \item Aceitar as mudanças de requisito a qualquer momento dentro do projeto;
  \item Entrega de \textit{software} em funcionamento com frequência semanal ou mensal;
  \item Pessoas que entendem do negócio e desenvolvedores devem estar sempre trabalhando juntas
  durante o processo de desenvolvimento;
  \item Trabalhar com pessoas motivadas no projeto, dando a eles um bom ambiente
  de trabalho e confiar que farão aquele que foi designado a eles;
  \item A melhor maneira de se transmitir informação é por meio de uma conversa pessoal;
  \item \textit{Software} funcional é a medida primária de progresso;
  \item Processos ágeis promovem um ambiente sustentável;
  \item Contínua atenção a excelência técnica e bom design;
  \item Simplicidade;
  \item As melhores arquiteturas, requisitos e designs emergem de times auto-organizáveis;
  \item Em intervalos regulares, o time reflete em como ficar mais efetivo,
  então, se ajustam e aperfeiçoam seu comportamento de acordo.
\end{itemize}

Por meio desses princípios e valores pode-se notar que as metodologias
ágeis deixam de lado a documentação pesada, processos de extração e
elaboração de requisitos e passam a valorizar mais o \textit{software} funcionando,
liberando pequenas versões à medida que as mesmas ficam prontas, trazem o
cliente para dentro do processo de desenvolvimento fazendo o mesmo participar e
acompanhar o crescimento do projeto, enfatiza interação entre pessoas sejam elas
do time de desenvolvimento ou pessoas que entendem do negócio e abraçam
mudanças no \textit{software} a qualquer momento \cite{Fowler} \cite{Beck}.

\section{Extreme Programming (XP)}

A \textit{Extreme Programming} mais conhecida com XP é uma metodologia de
desenvolvimento que tem como finalidade entregar \textit{software} de qualidade e com as
necessidades que o cliente realmente precisa.

É uma metodologia voltada para pequenos e médios times de desenvolvimento que trabalham em projetos orientados a objetos e que seus requisitos podem sofrer constantes mudanças. \cite{Kuhn}

A satisfação do cliente é o que faz a metodologia ser bem sucedida. O XP
busca o máximo desempenho da equipe mantendo um ritmo saudável de trabalho
onde horas extra só são realizadas se forem agregar algo de valor ao produto final.

O cliente obterá seu produto em pequenos lançamentos, podendo utilizá-lo,
aprender com o mesmo e avaliar se o que foi desenvolvido era o desejado. \cite{DesenvolvimentoAgil:XP}

\cite{DesenvolvimentoAgil:XP} menciona os valores seguidos pelo XP:

\begin{itemize}
  \item \textbf{\textit{Feedback}:} Quanto mais cedo um problema for descoberto, menos prejuízo e atraso ao
  \textit{software} ele dará e maiores são chances de ele ser resolvido rapidamente;

  \item \textbf{Comunicação:} Da várias formas de se comunicar existentes, times que utilizam XP prezam
  por uma conversa presencial para melhorar a compreensão e entendimento entre os membros;

  \item \textbf{Simplicidade:} Embora muitas vezes no desenvolvimento é um hábito desenvolver pensando
  em futuras implementações, no XP o time é focado em desenvolver o que é necessário para agora, entregando
  o que realmente o cliente necessita para o momento, deixando o que vier depois, para depois;

  \item \textbf{Coragem:} Equipes de desenvolvimento precisam encarar mudanças constantes nos projetos e para
  isso é necessário coragem e confiança em suas práticas;

  \item \textbf{Respeito} É o valor mais básico e serve de base a todos, pois dará confiança e respeito a toda equipe durante o processo.
\end{itemize}

Aliado aos valores e princípios a metologia XP também possui uma série de práticas para descrever quais atitudes
a equipe deve tomar no ambiente de trabalho e como se deve ocorrer o processo de desenvolvimento pela equipe
\cite{DesenvolvimentoAgil:XP}.

\begin{itemize}
  \item \textbf{\textit{Design} simples e incremental:} O desenvolvimento da aplicação será de maneira iterativa e incremental, ou seja, a equipe se focará em desenvolver os \textit{software} do modo mais simples possível, dando valor e codificando o que é realmente necessário para o cliente e permitindo o \textit{software} crescer aos poucos;

  \item \textbf{Programação em pares:} É uma prática que visa nivelar o trabalho da equipe, sugerindo que dois
  programadores trabalhem juntos de forma colaborativa na mesma tarefa, enquanto um foca sua atenção na criação do código o outro tera o trabalho de revisar e manter o primeiro focado na solução mais simples;

  \item \textbf{Código de posse coletiva:} Em um projeto todos tem responsabilidade e liberdade de alterar todo e qualque código encontrado, o código não pertence a ninguém e sim a todo mundo. Isso ocorre quando equipes
  trocam de membro de forma constante e abordando o código dessa maneira é mais fácil transmitir o conhecimento do projeto, sem atrelar determinados códigos ou funcionalidades a determinados desenvolvedores;

  \item \textbf{Desenvolvimento guiado por testes:} É a prática que propoem a crição dos testes antes mesmo do código de produção ser implementado, tem como objetivo maior detectar e solucionar
  todas as possíveis falhas do desenvolvimento por meio dos testes. Dessa forma, quando um código é terminado
  não é preciso voltar até ele para testá-lo, pois ele já estará testado e pronto.
\end{itemize}

\section{Scrum}

Após a criação do Manifesto Ágil, surgiram várias metodologias que visavam tirar proveito
dos valores e princípios, em 1990 surge o \textit{Scrum} que segue a seguinte definição:

\begin{quotation}
"\textit{Scrum} é um \textit{framework} Ágil, simples e leve, utilizado para a gestão do
desenvolvimento de produtos complexos imersos em ambientes complexos.
\textit{Scrum} é embasado no empirismo e utiliza uma abordagem iterativa
e incremental para entregar valor com frequência e, assim,
reduzir os riscos do projeto". \cite{LivroScrumCasaDoCodigo}
\end{quotation}

Embora o \textit{Scrum} vise ser menos burocrático que outras metologias, ele trás consigo
uma série de definições e papéis para melhor organizar sua equipe e seus processos. Porém
pelo fato de ser definido como um \textit{framework}, não há um processo rígido fixo e sim
um processo que pode ser adaptado para cada projeto e cada equipe.

Em sua forma mais básica o \textit{Scrum} é composto por um time, seus artefatos e seus eventos.
O processo de desenvolvimento é baseado em \textit{Sprints}, onde o time irá interagir e trabalhar
no projeto. \cite{DesenvolvimentoAgil:Scrum} \cite{LivroScrumCasaDoCodigo}

A visão geral do processo de \textit{Sprint} pode ser vista na Figura \ref{figura_1} abaixo:

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/sprint.jpg}
    \caption{Visão geral de uma \textit{Sprint} dentro do \textit{Scrum}}
    \label{figura_1}
    \cite{Jamil}
  \end{center}
\end{figure}

\subsection{O time do Scrum}

Segundo \cite{LivroScrumCasaDoCodigo} dentro do \textit{Scrum} existem três papéis definidos: o Time de desenvolvimento, \textit{Scrum Master}.

\begin{itemize}
  \item \textbf{Time de desenvolvimento:} Geralmente é uma equipe composta de 3 a 10 pessoas e são os
  responsáveis pela entrega do produto. Formam um time auto-organizado, multidisciplinar, motivado e com foco em qualidade. Dentro do time não há divisões entre programadores, \textit{designers}, engenheiros ou analistas;

  \item \textit{\textbf{Product Owner:}} É o responsável pela visão do produto, por tomar as decisões de negócio, definir e priorizar as atividades do \textit{Product Backlog}, ele representa a necessidade
  do cliente em relação ao produto que está sendo desenvolvido;

  \item \textit{\textbf{Scrum Master:}} É o responsável por garantir o funcionamento e execução do \textit{Scrum} no
  decorrer de uma \textit{Sprint}. Possui além de conhecimentos técnicos, habilidade de gerenciar pessoas,
  técnicas para facilitar o trabalho e está sempre tentando remover qualquer bloqueio
  que possa impedir o time de desenvolvimento.
\end{itemize}

Embora existam essas três separações, toda equipe é igualmente responsável
e responsabilizada pelo resultados obtidos, isso faz com que todos se comprometam com o projeto inteiramente.

Todos os membros juntos, formam o chamado Time do \textit{Scrum}, todos visam trabalhar juntos de forma colaborativa,
para que como equipe todos consigam alcançar um único objetivo coletivo.
\cite{LivroScrumCasaDoCodigo} \cite{GuiaDoScrum}

\subsection{Artefatos do Scrum}

Os artefatos do \textit{Scrum} servem como ferramentas de opoio a todo o time, afim de que todos
possam ter um acompanhamento geral dos trabalho durante a \textit{Sprint} e uma visão geral
do andamento do produto que está sendo feito.

Conforme \cite{DesenvolvimentoAgil:Scrum} e \cite{DesenvolvimentoAgil:Scrum} os artefatos mais comuns são:

\begin{itemize}
  \item \textit{\textbf{Product Backlog:}} É lista de funcionalidades desejadas para o produto que está sendo desenvolvido. É responsabilidade do \textit{Produto Owner} adicionar, remover, priorizar todas as tarefas
  dentro do \textit{Product Backlog};

  \item \textit{\textbf{Sprint Backlog:}} É lista de funcionalidades extraídas de dentro do
  \textit{Product Backlog} que serão desenvolvidas durante uma
  \textit{Sprint} pelo time de desenvolvimento. Os itens são extraídos de acordo
  com a priorização do \textit{Product Owner} e a equipe tem a liberadade de escolher
  os itens que são inclusos;

  \item \textit{\textbf{User Story:}} É descrição de uma real necessidade do projeto,
  ou seja, uma funcionalidade esperada no sistema. É escrita do ponto de vista do usuário e
  ele deverá descrever o que deseja fazer e como deseja fazer.
    \begin{itemize}
      \item \textbf{Como um} - papel dentro do \textit{software};
      \item \textbf{Eu quero} - funcionalidade que espera executar;
      \item \textbf{Para que} - objetivo para o qual essa funcinalidade será criada.
    \end{itemize}
\end{itemize}

\subsection{Eventos do Scrum}

Eventos do \textit{Scrum}, são na verdade o próprio ciclo de desenvolvimento, denominado \textit{Sprint}.
Durante o período da \textit{Sprint} a equipe faz um série de cerimônias com objetivo de atualizar todos
os membros sobre o andamento do trabalho e também ajuda a detectar algum possível impedimento para o
escopo da \textit{Sprint}. \cite{GuiaDoScrum} \cite{LivroScrumCasaDoCodigo}

Segundo \cite{GuiaDoScrum} e \cite{LivroScrumCasaDoCodigo} o principais eventos dentro do \textit{Scrum}, são:

\begin{itemize}
  \item \textit{\textbf{Sprint:}} É um mini-projeto, que tem duração entre 1 e 4 semanas
  e é durante esse intervalo de tempo que o Time de desenvolvimento faz o incremento do produto.
  O objetivo maior da \textit{Sprint} é que ao seu final uma nova parte utilizável do software seja entregue.

  \item \textit{\textbf{Sprint Planning:}} É uma reunião com participação de todos os envolvidos
  onde o \textit{Product Owner} mostra quais as atividides de maior prioridade naquele momento
  e a equipe irá selecionar quais dessas atividades entram na \textit{Sprint}
  para gerar um novo incremento no \textit{software};

  \item \textit{\textbf{Dayli Scrum:}} É uma reunião curta e realizada todos os dias pela equipe de desenvolvimento, geralmente ocorre sempre no mesmo horário e tem uma duração de aproximadamente 15 minutos.
  Durante os \textit{Dayli Scrums} todos os membros da equipe se focam em responder três perguntas:
  \begin{itemize}
    \item O que eu fiz ontem ?;
    \item O que eu farei hoje ?;
    \item Algum impedimento para o que eu fiz ontem ou terei que fazer hoje ?
  \end{itemize}

  \item \textit{\textbf{Sprint Review:}} é uma reunião feita com toda a equipe ao final de uma \textit{Sprint}.
  Tem como objetivo avaliar tudo que foi feito ao longo da \textit{Sprint}, se o que foi feito
  está de acordo com o que foi combinado na reunião de \textit{Sprint Planning} e se irá
  entrega um novo incremento ao \textit{software};

  \item \textit{\textbf{Sprint Retrospective:}} É uma análise feita entre o a \textit{Sprint Review} e a próxima
  \textit{Sprint Planning}, serve para avaliar o que foi feito na última \textit{Sprint},
  quais pontos do processo foram falhos, quais ajudaram a equipe a ter uma melhor performance
  e quais pontos podem ser melhorados para otimização da equipe.
\end{itemize}

\section{Qualidade de Software}

Segundo \cite{Pressman}

\begin{quote}
Conformidade a requisitos funcionais e de
desempenho explicitamente declarados, a padrões de desenvolvimento claramente
documentados e a características implícitas que são esperadas de todo \textit{software}
profissionalmente desenvolvido.
\end{quote}

A qualidade de \textit{software} não pode estar ligada somente ao \textit{software} fazer
algo certo, como foi pedido pelo cliente e também não se restringe ao \textit{software} final
criado. Qualidade de \textit{software} está ligada também a qualidade do código,
reusabilidade, manuteabilidade, aos processos adotados durante o desenvolvimento
como análise de requisitos e documentação.

Existem fatores para determinar a qualidade de \textit{software} \cite{Pressman}:

\begin{itemize}
  \item \textbf{Corretitude:} O \textit{software} satifaz as especificações determinadas e
  cumpre os objetivos desejados pelo cliente;
  \item \textbf{Confiabilidade:} O \textit{software} executar determinada funcionalidade com
  a precisão esperada;
  \item \textbf{Eficiência:} Quantidade de recursos computacionais e de código
  exigida pelo \textit{software} para executar uma funcionalidade;
  \item \textbf{Integridade:} Controlar acesso ao \textit{software} ou a dados a pessoas não
  autorizadas;
  \item \textbf{Usabilidade:} Esforço para aprender, operar e preparar a entrada e
  interpretar uma saída do \textit{software};
  \item \textbf{Manuteabilidade:} Esforço para localizar e reparar erros no \textit{software};
  \item \textbf{Flexibilidade:} Esforço para modificar um programa operacional;
  \item \textbf{Testabilidade:}  Esforço exigido para testar um \textit{software} a fim de
  garantir que ele execute uma funcionalidade pretendida;
  \item \textbf{Portabilidade:} Esforço exigido para transferir o programa de um
  ambiente de sistema de \textit{hardware}/\textit{software} para outro;
  \item \textbf{Reusabilidade:} À medida que um \textit{software} cresce possibilita algumas
  de suas partes serem reutilizadas em outros ou até no mesmo \textit{software};
  \item \textbf{Interoperabilidade:} Esforço exigido para se acoplar um sistema a outro.
\end{itemize}

Essas são os fatores propostos por McCall, Richards e Walters (1977) e
citados por \cite{Pressman}. Esses fatores podem ser agrupados e representados conforme a Figura \ref{figura_4}.

\clearpage

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/qualidade-de-software.jpg}
    \caption{A Pirâmide de qualidade de \textit{software}}
    \label{figura_4}
    \cite{FabioMartinhoCampos}
  \end{center}
\end{figure}

\section{Testes de Software}

A evolução tecnologica vivenciada por nós nos dias atuais nos traz uma comodidade muito grande, o uso de \textit{notebooks} e \textit{smartphones} facilita cada vez mais as atividades e nossa comunicação. Meios de transporte
como carros e aviões também estão cada vez mais dependentes de tecnologia e \textit{softwares} para facilitar a atividade e trazer uma maior segurança, além desses, sistemas bancários e telefônicos possuem grandes \textit{softwares} e necessitam estar sempre em funcionamento.

O lado negativo de todo esse avanço, é que nos torna refens da tecnologia e uma falha gerada por algum desses dispositivos pode ser catastrófica e trazer grandes prejuízos financeiros.

Ao longo dos anos a indústria de \textit{software} acumula algumas grandes falhas, citadas por \cite{FalhasDeSoftware:PedroCosta} e \cite{FalhasDeSoftware:ProfissionaisTI} :

\begin{itemize}
  \item \textbf{Apagão nos EUA:} Um incidente causado por uma falha no sistema de alarmes deixou mais de 50 milhões de pessoas sem luz e causou 11 mortes;
  \item \textbf{Recall da Honda:} uma falha de programação no sistema de \textit{airbag} dos carros, fez com que a \textit{Honda}, fosse forçada a fazer um \textit{recall} de mais de 2 milhões de automóveis e custou milhões a empresa japonesa;
  \item \textbf{Radiação em excesso:} Entre os anos de 1985 e 1987, hospitais dos EUA utlizavam um aparelho chamado \textit{Therac-25} para o tratamento com radicação contra o câncer, um erro de programação no \textit{software} fazia com que a máquina aplicasse uma dosagem até 100 vezes maior do que a indicada para os pacientes, foram registradas 6 mortes por conta dessa falha;
  \item \textbf{Foguete Mariner:} uma fórmula matemática falha introduzida por uma programador fez com que o foguete fosse para fora do seu curso, causando um prejuízo de 18 milhões de dólares;
  \item \textbf{Míssil na guerra do Golfo:} durante a guerra, um sistema de mísseis americanos falhou na interceptação de um míssil inimigo e o acampamento dos soldados foi destruído causando 28 mortes;
\end{itemize}

Essas falhas colocam como cada vez mais prioritária a necessidade de se garantir a qualidade e funcionamento do \textit{softwares} através de testes bem feitos, melhor elaborados e mais precisos.

Teste de \textit{software} pode ser definido como um processo de execução de um produto, para determinar se o mesmo atingiu suas necessidades e se seu funcionamento ocorreu de forma correta e segura. O maior objetivo do processo de testes é detectar falhas e previni-lás ainda durante o desenvolvimento, para evitar
que essas falhas sejam descobertas por usuários e não causem danos e nem prejuízos. \cite{Pressman}

Segundo \cite{Pressman} testes de \textit{software} devem abordar todos os níveis do projeto e podem ser
classificados como:

\begin{itemize}
  \item \textbf{Testes de Unidade:} Focam em testar cada pequeno componente do sistema, garantindo sua funcionalidade e também garatem que cada pequeno componente consiga funcionar de forma isoloada;

  \item \textbf{Teste de Integração:} Visa testar o fluxo do sistema como um todo e garantir que todas
  as interações funcionem entre si;

  \item \textbf{Teste de Validação:} Visa testar se os requisitos estão funcionando da mesma forma no \textit{software} de como foram levantados na análise;

  \item \textbf{Teste de Sistema:} Foca em testar a combinação do \textit{software} com outros elementos de \textit{hardware}, banco de dados e usuários reais. Também visa garantir que o projeto atendeu a necessidade
  para o qual ele foi criado.
\end{itemize}

\cite{Pressman} ainda sugere que os teste  podem ser vistos em forma de espiral conforme
a Figura \ref{figura_5}, partindo da menor unidade do \textit{software} até sua integração total e seu uso.

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/espiral-teste-de-software.jpg}
    \caption{O espiral dos testes de \textit{software}}
    \label{figura_5}
    \cite{Pressman}
  \end{center}
\end{figure}

Dessa forma é possível notar que a atividade de testar \textit{software} deve se tornar cada vez mais importante
nos projetos, para garantir não só sua qualidade, mas também eliminar riscos de falhas do projeto e garatir
a satisfação do cliente.

\section{Test Driven Development (TDD)}

O TDD (\textit{Test Driven Development} ou Desenvolvimento Guiado por Testes) é a prática de desenvolvimento de \textit{software} onde os testes automatizados são criados antes de qualquer código real seja implementado, deixando a
codificação real para um segundo momento, forçando o desenvolvedor a focar sempre na simplicidade, refatorando seu código sempre que possível e buscando deixar o código sempre enxuto. \cite{TDD:Aniche}

A utilização dessa abordagem possibilita ao desenvolvedor tenha ao final do processo uma aplicação funcional, com uma estrutura bem feita e altamente testável. \cite{TDD:Aniche}

\cite{Beck} enfatiza duas regras principais que devem ser seguidas quando se utiliza TDD:

\begin{itemize}
  \item Escrever código novo somente quando um teste automatizado falhar;
  \item Eliminar código duplicado.
\end{itemize}

Segundo \cite{Beck} a prática do TDD segue um ciclo chamado vermelho-verde-refatorar (\textit{red}-\textit{green}-\textit{refactor}) como mostra a Figura \ref{figura_6} e pode ser definido da seguinte forma:

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/ciclo-tdd.jpg}
    \caption{O ciclo do TDD}
    \label{figura_6}
    \cite{Imagem:TDD}
  \end{center}
\end{figure}

\begin{enumerate}
  \item \textbf{Vermelho:} Desenvolvedor escreve um código que falhe;
  \item \textbf{Verde:} Desenvolvedor escreve o mínimo de código necessário para que o teste passe, sem
  se preocupar com a qualidade do que foi codificado, apenas foca que o teste passe;
  \item \textbf{Refatorar:} Como o teste já está verde, agora o desenvolvedor irá focar na melhoria do código escrito anteriomente.
\end{enumerate}

Segundo \cite{TDD:Aniche} a utilização dessa prática de desenvolvimento trará vantagens ao desenvolvedor, sendo elas:

\begin{itemize}
  \item \textbf{Focar no teste e não na sua implementação:} Nessa abordagem, o desenvolvedor irá focar em codificar apenas aquilo que o teste necessita, dessa forma ele irá focar apenas naquela classe ou trecho de código que está testando, deixando de lado um tempo a sua implementação;
  \item \textbf{Código nasce testado:} Quando o desenvolvedor segue esse ciclo, ele irá garantir que cada
  pedaço do código final tenha ao menos um teste sobre ele para assegurar seu funcionamento;
  \item \textbf{Simplicidade:} Quando o desenvolvedor aplica o ciclo ele sempre irá se preocupar em fazer o teste passar e irá focar seus esforços em um teste por vez, isso fará com que ele codifique sempre da forma mais simples, deixando de lado soluções mirabolantes ou complexas;
  \item \textbf{Melhor compreensão sobre o \textit{design} das classes:} Como o desenvolvedor irá focar sempre
  em um teste e uma classe por vez, irá deixar de lado por um momento a integração geral das classes e irá
  se preocupar em manter simples a classe na qual está trabalhando, aumentando a sua coesão e diminuindo seu
  acoplamento.
\end{itemize}

\cite{TDD:Aniche} e \cite{Beck} também dizem que os testes podem refletir sobre a saúde do código, quando um teste é complicado de se escrever é um sinal que o código pode estar ruim ou não estar fazendo aquilo que realmente deveria fazer.

Dentro das práticas do TDD ainda existe uma prática chamada \textit{baby steps} que pode ser definida com a prática onde
o código cresce aos poucos de forma incremental, forçando o desenvolvedor a focar em um método por vez, praticando o ciclo do TDD em cada um dos métodos e classes do projeto.

Segundo \cite{TDD:Aniche} a prática do \textit{baby steps} aliado ao TDD irá proporcionar ao desenvolvedor receber um \textit{feedback} mais rápido e constante do seu código, podendo previnir e arrumar falhas de codificação de forma imediata diminuindo os custos e previnindo futuras manutenções no código.

A Figura \ref{figura_7} mostra como é a forma de recebimento do \textit{feedback} do código pelo desenvolvedor
que prática o TDD e um desenvolvedor que não prática TDD.

\clearpage

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/feedback-tdd.png}
    \caption{\textit{Feedback} do código utilizando TDD}
    \label{figura_7}
    \cite{TDD:Aniche}
  \end{center}
\end{figure}

Dessa forma é possível notar que a prática do TDD além de garantir um melhor código,
criar uma base sólidas de testes de unidade ao \textit{software}
também irá ajudar na prevenção de erros e quando erros surgirem, o desenvolvedor poderá
corrigi-lo mais rapidamente, evitando que esses erros possas se propagar e prejudicar todo o projeto.

\section{Behavior Driven Development (BDD)}

O BDD (\textit{Behavior Driven Development} ou Desenvolvimento Guiado por Comportamento)
é uma prática de desenvolvimento de \textit{software} que tenta gerar uma maior integração
entre equipes de negócio e desenvolvimento. \cite{BDD:CasaDoCodigo}

Nessa prática as equipes irão se focar em descrever um comportamento esperado pelo
\textit{software} para após isso desenvolvedor o código necessário que irá solucionar o cenário desse comportamento, dessa forma pode-se validar se de fato o código criado irá atender
a necessidade de negócio e se comportar de modo acertivo. \cite{BDD:CasaDoCodigo}

O BDD pode ser dito como um evolução sobre o TDD, visto que o TDD foca na construção do código, BDD
se preocupa em saber se o código criado irá se comporta de forma esperada e se
consegue entregar a implementação da funcionalidade de forma esperada.

O BDD fornece uma maneira com que equipes de áreas diferentes consigam trabalhar e
escrever os cenários de teste juntas, já que a prática utiliza uma Linguagem Ubíqua na descrição dos seus cenários. \cite{BDD:CasaDoCodigo} \cite{BDD:Soares}

O surgimento do BDD começou quando Dan North sentiu dificuldades de ensinar TDD para seus alunos
por conta de sua nomeclatura e da utilização da palavra teste.
Seus alunos sentiam certa dificuldade em saber por onde começar a especificação.
Dan North então se focou em escrever o primeiro \textit{framework} para de utilizar
BDD, surgiu então o \textit{JBehave}. Essa nova ferramenta tinha como foco tirar a referência da palavra teste
e substituir por um vocabulário onde o foco fosse o comportamento. \cite{BDD:CasaDoCodigo} \cite{BDD:DanNorth}

\cite{BDD:Sanchez} cita as principais alterações feitas por Dan North, na tentantiva de remover o conceito de teste e focar na descrição do comportamento:

\begin{itemize}
  \item Uso de \textit{\textbf{Context}} ao invés de \textit{TestCase};
  \item Uso de \textit{\textbf{Specification}} ao invés de \textit{Test};
  \item Uso de \textit{\textbf{Should}} ao invés de \textit{Assert}.
\end{itemize}

Além dessas, também foram introduzidas novas formas de criar cenários e validar seus critérios de aceitação
\cite{BDD:CasaDoCodigo}:

\begin{itemize}
  \item \textit{\textbf{Feature}} que servirá para especificar e testar uma funcionalidade;
  \item \textit{\textbf{Scenario}} irá descrever o cenário para qual o teste deve cobrir
  e quais seus critérios de aceitação;
  \item \textit{\textbf{Steps}} um cenário é composto por vários \textit{steps}, esses \textit{steps} irão
  descrever o que se espera do \textit{software} e servirão de critério de aceitação.
\end{itemize}

Uma especificação de comportamento no BDD é descrita de forma muito similar a uma \textit{User Story} do
\textit{Scrum} e por isso é uma prática dentro de times \textit{Scrum} a utilização do BDD.
Outro ponto importante da utilização do BDD no processo de desenvolvimento é que as especificações
ao longo do tempo, acabam se tornando uma documentação viva do sistema. \cite{BDD:Sanchez}

De forma simples, uma especificação é composta da seguinte maneira:

\begin{itemize}
  \item \textbf{Como um} - papel dentro do \textit{software};
  \item \textbf{Eu quero} - funcionalidade que espera executar;
  \item \textbf{Para que} - objetivo para o qual essa funcinalidade será criada.
\end{itemize}

E para a descrição do cenário do comportamento:

\begin{itemize}
  \item \textbf{Dado} - é o contexto inicial;
  \item \textbf{Quando} - ocorre a execução de alguma atividade;
  \item \textbf{Então} - descreve qual o resultado esperado para essa execução.
\end{itemize}

A abordagem de desenvolvimento utilizando BDD propõe que o \textit{software} seja desenvolvido
especificando as várias camadas do comportamento com testes automatizados seguindo uma abordagem
chamada de \textit{outside-in development}, ou seja, deve-se começar com a especificação de um comportamento
de uma funcionalidade, após isso codificar as classes e métodos necessárias para satisfazer
esse comportamento. \cite{BDD:CasaDoCodigo}

Na Figura \ref{figura_8} visa ilustrar a forma de desenvolvimento proposta pelo BDD:

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/ciclo-bdd.png}
    \caption{O ciclo do BDD}
    \label{figura_8}
    \cite{RubySoftware}
  \end{center}
\end{figure}

Segundo \cite{BDD:CasaDoCodigo} e \cite{BDD:Sanchez} as etapas do processo de desenvolvimento
seguindo o BDD ocorrem da seguinte forma:

\begin{itemize}
  \item Na primeira etapa do ciclo a equipe deve escrever um novo comportamento esperado
  pelo \textit{software} e ao executar essa especificação ela deve falhar;

  \item Na segunda etapa do ciclo a equipe entra no ciclo do TDD, escrevendo um teste de unidade
  que também deverá falhar;

  \item Na terceira etapa do ciclo deve-se codificar o mínimo necessário de código para que o teste feito
  na segunda etapa passe;

  \item Na quarta etapa o código escrito na terceira etapa deverá ser refatorado e após a refatoração
  é necessário certificar-se de que o teste de unidade escrito na etapa dois, continue passando;

  \item Na quinta e última etapa do ciclo, após o código ter sido codificado e refatorado é necessário
  executar novamente a especificação e verificar que o comportamento está sendo
  executado corretamente.
\end{itemize}

Com o desenvolvimento seguindo essa abordagem é possível verificar como o BDD utiliza o TDD, porém eleva o nível do teste para o nível de especificação, saindo do escopo de apenas estar testando código.
Permite então, que a equipe realmente veja que o código feito atende
a necessidade, funciona corretamente e implementa a funcionalidade de forma esperada.

\section{Linguagem Ruby}

A linguagem foi criada no ano de 1995 no Japão Yukihiro "Matz" Matsumoto,
é uma linguagem orientada a objeto interpretada, de tipagem forte e dinâmica.
Foi criada baseada no que havia de melhor me outras
linguagens como: \textit{Smalltalk}, \textit{Lisp} e \textit{Ada}.
Tudo em \textit{Ruby} é objeto e sua sintaxe simples visa facilitar o desenvolvedor
tanto na hora de escrever código como também na hora
de ler código de outros desenvolvedores.

É \textit{open-source} o que possibilita aos desenvolvedores abrirem e melhorem o
código fonte sempre que julgarem necessário, o que possibilita uma
constante na correção de erros, facilitando melhorias e inclusões de novas
funcionalidades a linguagem. \cite{Ruby:Thomas}

Na Figura \ref{figura_9} é possível ver um exemplo de código Ruby:

\clearpage

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/ling-ruby-2.png}
    \caption{Exemplo de código Ruby}
    \label{figura_9}
    Autoria Própria
  \end{center}
\end{figure}

Na primeira linha da Figura \ref{figura_9} está sendo criado uma nova variável
chamada \textit{number} e sendo atribuído um valor 10, como \textit{Ruby} possui uma tipagem dinâmica e 10 é um valor de tipo número inteiro, o interpretador irá entender que a variável \textit{number}
será do tipo \textit{Fixnum}.

O mesmo ocorre para a variável \textit{name}, que foi criada recebendo uma \textit{string} "Luiz", o interpretador irá entender que \textit{name} é um valor do tipo \textit{String}

Como em Ruby tudo é um objeto é possível fazer a checagem de qual tipo de objeto as variáveis \textit{number}
e \textit{name} pertecem, nesse caso \textit{Fixnum} e \textit{String} respectivamente.

Como \textit{Ruby} possui uma tipagem forte, ele não irá permitir que as duas variáveis, um \textit{Fixnum} e uma \textit{String}, executem a operação de soma, exibindo um erro.

\chapter{Materiais e Métodos}

Este capítulo tem como objetivo descrever as ferramentas e tecnologias utilizadas no desenvolvimento
da aplicação experimental.

\section{Tecnologias Utilizadas}

Para o desenvolvimento do estudo experimental foram utilizadas as seguintes tecnologias e ferramentas:

\begin{itemize}
  \item Linguagem \textit{Ruby};
  \item \textit{Framework} \textit{RSpec};
  \item \textit{Framework} \textit{Cubumber};
  \item \textit{Framework Web} \textit{Sinatra};
  \item Editor de texto \textit{Sublime Text};
\end{itemize}

A linguagem \textit{Ruby} utilizada no estudo experimental se encontra na versão 2.2.2, sendo essa a sua última
versão estável.

O \textit{RSpec} é um \textit{framework} para criação de testes unitários que segue a filosofia do BDD.

O \textit{Cucumber} é um \textit{framework} para automatizar a criação de testes de aceitação
e validar o comportamento do \textit{software}, com ele é
possível escrever especificações executáveis de do ponto de vista do usuário.

O editor \textit{Sublime Text} foi escolhido por ser um editor simples, leve
e permite a instalação de diversos \textit{plugins} para diversas linaguagens,
para facilitar o seu uso.

E o \textit{Sinatra} é um \textit{micro-framework web} escrito em \textit{Ruby} que
tem como grande vantagem ser leve e possibilitar um desenvolvimento flexível e rápido
para aplicações \textit{web} de pequeno porte.

\section{Estudo Experimental}

Nesta seção será descrito o procedimento da aplicação experimental para validar a utilização
do BDD no processo de desenvolvimento.

O estudo experimental proposto, será uma aplicação que irá realizar o cálculo do salário líquido,
conforme Tabela \ref{tabela_1} do Imposto de Renda (IR) e Tabela \ref{tabela_2} referente ao
Instituto Nacional do Seguro Social (INSS).

\begin{table}[h]
\centering
\caption{Tabela do Cálculo do Imposto de Renda - 2015}
\label{tabela_1}
  \begin{tabular}{ccc}

  \hline

  Base de cálculo & Alíquota em \% & Parcela a deduzir em R\$ \\

  \hline

  Até 1.903,98             & -    & -       \\
  De 1.903,99 até 2.826,65 & 7,5  & 142,80  \\
  De 2.826,66 até 3.751,05 & 15,0 & 354,80  \\
  De 3.751,06 até 4.664,68 & 22,5 & 636,13  \\
  Acima de 4.664,68        & 27,5 & 869,36

  \end{tabular}
\end{table}

\begin{table}[h]
\centering
\caption{Tabela do Cálculo do INSS - 2015}
\label{tabela_2}
  \begin{tabular}{ccc}

  \hline

  Base de cálculo & Alíquota em \% \\

  \hline

  Até 1.399,12             & 8 \\
  De 1.399,13 até 2.331,88 & 9 \\
  De 2.331,89 até 4.663,75 & 11

  \end{tabular}
\end{table}

O propósito da aplicação é que dado um valor de salário líquido, a aplicação
deverá retornar a alíquota e o valor em reais referente ao IR e ao INSS do valor informado.

\clearpage

Na primeira etapa é necessário criar a estrutura inicial da aplicação \textit{web}
conforme Figura \ref{figura_10}.

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/estrutura-app.png}
    \caption{Estrutura inicial da aplicação}
    \label{figura_10}
    Autoria Própria
  \end{center}
\end{figure}

Os principais itens dessa estrutura são:

\begin{itemize}
  \item \textit{\textbf{features:}} É o diretório onde estarão os testes de aceitação;

  \item \textit{\textbf{features/step-definitions:}} É o diretório onde serão
  escritos os passos para validação do teste de aceitação;

  \item \textit{\textbf{features/support:}} É o diretório onde serão escritos códigos
  que poderão ser utilizados de forma à auxiliar os testes de aceitação;

  \item \textit{\textbf{lib:}} É o diretório onde está o código da aplicação;

  \item \textit{\textbf{spec/lib:}} É o diretório responsável por armazenar os testes de unidade
  dos códigos escritos dentro de \textit{lib};

  \item \textit{\textbf{views:}} É o diretório onde as telas do projeto estarão
  armazenadas;

  \item \textit{\textbf{app.rb:}} É o arquivo que inicia a aplicação;
\end{itemize}

O passo seguinte é configurar os \textit{frameworks} de testes que serão utilizados,
conforme Figura \ref{figura_11}

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/rubygems.png}
    \caption{Configuração dos \textit{frameworks} de teste}
    \label{figura_11}
    Autoria Própria
  \end{center}
\end{figure}

Com a aplicação devidamente configurada, é possível iniciar o desenvolvimento.

O \textit{framework Cucumber}, que será utilizado para a criação das especificações
possui um padrão de linguagem chamado \textit{Gherkin} que possui um vocabulário próprio
e permite que as especificações sejam escritas na linguagem nativa da equipe ou desenvolvedor.

O primeiro passo para o desenvolvimento é criar um primeiro teste de aceitação, para validar
os cálculos que serão efetuados pela aplicação, conforme visto na Figura \ref{figura_12}:

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/app-1.png}
    \caption{Criando primeiro teste de aceitação}
    \label{figura_12}
    Autoria Própria
  \end{center}
\end{figure}

Após criado o arquivo de especificação é possível executá-lo, com o comando \textit{bundle exec cucumber},
porém como nesse momento só existe o código da especificação, não será possível validar a aplicação e
ele apenas irá informar que a especificação ainda não foi escrita, conforme a
Figura \ref{figura_13}.

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/app-2.png}
    \caption{Executando primerio teste de aceitação}
    \label{figura_13}
    Autoria Própria
  \end{center}
\end{figure}

A saída do comando também irá sugerir que sejam copiados os passos do teste sugeridos e
crie-se um arquivo \textit{Ruby} no diretório \textit{features/step-definitions} contendo todos os
passos da especificação, conforme a Figura \ref{figura_14}.

\clearpage

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/app-3.png}
    \caption{Passos do teste de aceitação ainda pendentes}
    \label{figura_14}
    Autoria Própria
  \end{center}
\end{figure}

Todos os arquivos contidos no diretório \textit{features/step-definitions} são os arquivos que farão
a conexão entre o arquivo de especificação e as classes \textit{Ruby} com o código real da aplicação.
Esses arquivos entendem e conseguem receber dados dos arquivos de teste de aceitação e também conseguem
se conectar com os arquivos de código da aplicação.

É esse ponto que o uso de BDD visa facilitar a integração entre as equipes, pois essas especificações
podem ser escritas em conjunto pela equipe e ao final do processo para garantir o correto funcionamento
do \textit{software} basta a equipe toda se focar na execução e validação dessas especificações.

Após copiar e colar em um arquivo \textit{Ruby} os passos sugeridos pelo \textit{Cucumber} para o teste,
é preciso iniciar o desenvolvimento desses passos, utilizando os códigos reais da aplicação.
Conforme Figura \ref{figura_15} os passos que antes eram pendentes agora irão possuir codigo que será
utilizado para a validação.

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/app-4.png}
    \caption{Criando os testes de aceitação reais}
    \label{figura_15}
    Autoria Própria
  \end{center}
\end{figure}

\clearpage

Ao executar esses testes de aceitação eles devem falhar pois ainda não foi feito criado código \textit{Ruby}
na aplicação para que os testes passem. Na Figura \ref{figura_16} é possível observar a execução de todos os passos
através do comando \textit{bundle exec cucumber} e verificar que todos os passos estão falhando.

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/app-5.png}
    \caption{Executando a especificação}
    \label{figura_16}
    Autoria Própria
  \end{center}
\end{figure}

Dessa forma é encerrada a primeira etapa no ciclo do BDD, onde foi criada uma especificação
que falha por não haver nenhum código de execução na aplicação, agora é possível iniciar o desenvolvimento
e entrar na segunda etapa do ciclo do BDD e iniciar a codificação utilizando TDD.

Conforme visto na Figura \ref{figura_16} os testes de aceitação falham pois a classe \textit{SalaryCalculator} ainda não existe. Obedecendo o ciclo do TDD o primeiro passo é criar um teste unitário que falhe,
essa é a fase do vermelho (\textit{red}) dentro do TDD.

Na Figura \ref{figura_17} está sendo criado o primeiro teste unitário, esse teste deverá
falhar pois ainda não há código dentro \textit{SalaryCalculator} apenas a sua definição.

\clearpage

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/app-6.png}
    \caption{Criando primeiro teste que irá falhar}
    \label{figura_17}
    Autoria Própria
  \end{center}
\end{figure}

Na Figura \ref{figura_18} está sendo executado o primeiro teste unitário para a classe \textit{SalaryCalculator}
e é possível observar que ele está falhando.

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/app-7.png}
    \caption{Executando testes unitários para a class \textit{SalaryCalculator}}
    \label{figura_18}
    Autoria Própria
  \end{center}
\end{figure}

Seguindo na segunda etapa do TDD, conhecida como verde (\textit{green}) é preciso criar um código da forma mais
simples possível, apenas para garantir que o teste passe de vermelho para verde.
A codificação simplificada é vista na Figura \ref{figura_19} e a execução do teste retornando
verde é vista na \ref{figura_20}.

\clearpage

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/app-8.png}
    \caption{Codificação mínima para a classe \textit{SalaryCalculator}}
    \label{figura_19}
    Autoria Própria
  \end{center}
\end{figure}

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/app-9.png}
    \caption{Executando testes unitários, agora todos passando}
    \label{figura_20}
    Autoria Própria
  \end{center}
\end{figure}

Nesse ponto a terceira etapa do ciclo do BDD foi cumprida, pois o código foi criado utilizando TDD
e agora está no estado verde, ou seja, o código atual está funcionando, porém o ciclo não termina
até a especificação também estar funcionando corretamente.

O código atual feito na Figura \ref{figura_19} está simples o suficiente e está no estado verde.
O próximo passo agora seria efetuar a refatoração (\textit{refactor}) para completar o ciclo do TDD,
porém o código atual já é o suficiente, não havendo necessidade de refatoração e podendo seguir para o próximo teste.

O próximo caso de teste unitário, serão os testes que dado um salário será preciso efetuar os cálculos
referentes ao valores de IRRF, INSS e retornar o salário líquido final.

Tomando como base a especificação escrita na Figura \ref{figura_12}, os testes unitários ficaram da seguinte forma,
como visto na Figura \ref{figura_21}.

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/app-11.png}
    \caption{Criando teste unitários de acordo com especificação}
    \label{figura_21}
    Autoria Própria
  \end{center}
\end{figure}

Na execução dos testes, presentes na Figura \ref{figura_22} todos estão falhando, seguindo o princípio do TDD,
que todos os testes devem falhar em primeiro momento.

\begin{figure}[hbt!]
  \begin{center}
    \epsfig{file=images/app-12.png}
    \caption{Executando testes unitários com base na especificação}
    \label{figura_22}
    Autoria Própria
  \end{center}
\end{figure}

Na etapa seguinte é preciso realizar a codificação mínima do código para que todos os testes passem.

% A especificação criada ainda falha pois não foi produzido todo o código necessário para validação
% da mesma, conforme pode ser vista na Figura \ref{figura_21}.

% \begin{figure}[hbt!]
%   \begin{center}
%     \epsfig{file=images/app-10.png}
%     \caption{Executando especificação que ainda falha}
%     \label{figura_21}
%     Autoria Própria
%   \end{center}
% \end{figure}

\chapter{Resultados e Discussões}
\chapter{Considerações Finais}


%Referencias:
\bibliographystyle{abnt-alf}
\bibliography{exemplo}

\end{document}
